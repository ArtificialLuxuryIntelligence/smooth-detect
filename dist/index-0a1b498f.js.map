{"version":3,"file":"index-0a1b498f.js","sources":["../src/helpers/helpers.js","../src/classes/Interpolator.js","../src/helpers/geometry.js","../src/classes/InterpolatedDetector.js","../src/constants.js","../src/classes/Detectors/__VectorDetector.js","../src/classes/Detectors/VDMesh.js","../src/classes/Detectors/VDIrisMesh.js","../src/classes/Detectors/VDHandpose.js","../src/defaultsMULTI.js","../src/nosePoseMULTI.js"],"sourcesContent":["/**\n * Simple object check.\n * @param item\n * @returns {boolean}\n */\nfunction isObject(item) {\n  return item && typeof item === 'object' && !Array.isArray(item);\n}\n\n/**\n * Deep merge two objects.\n * @param target\n * @param ...sources\n */\nfunction mergeDeep(target, ...sources) {\n  if (!sources.length) return target;\n  const source = sources.shift();\n\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (!target[key]) Object.assign(target, { [key]: {} });\n        mergeDeep(target[key], source[key]);\n      } else {\n        Object.assign(target, { [key]: source[key] });\n      }\n    }\n  }\n\n  return mergeDeep(target, ...sources);\n}\n\nexport { mergeDeep };\n","// takes a slow promise and allows it to be run quickly with values interpolated (using any function) when slow promise  has yet to return\n\n// slowPromise :FUNCTION returns a promise that takes some time to resolve\n// stepToward : FUNCTION called on previous calculated value and resolved value of promise\n// fps : frames per second for slowPromise to be called (leave as false if max fps for promise is desired)\n\nexport default class Interpolator {\n  constructor(slowPromise, stepToward, stepArg, fps = false) {\n    this.slowPromise = slowPromise;\n    this.stepToward = stepToward;\n    this.fast = null; //updated every iteration call (note: here it is the whole prediction object -  see defaults)\n    this.slow = null; //updated only when promise resolves\n    this.resolved = true;\n    this.fps = fps;\n    this.stepArg = stepArg; // 3rd argument supplied to stepToward (after prev value and target value (aka this.fast & this.slow) - i.e. stepDistance\n  }\n\n  interpolate(val) {\n    this.__updateFast();\n    this.__updateSlow(val);\n    return this.fast;\n  }\n  __updateFast() {\n    if (!this.fast) {\n      this.fast = this.slow;\n    } else {\n      this.fast = this.stepToward(this.fast, this.slow, this.stepArg);\n    }\n  }\n  async __updateSlow(val) {\n    if (!this.resolved) {\n      return;\n    }\n    if (this.resolved) {\n      this.resolved = false;\n      let v;\n\n      if (this.fps) {\n        const [p1, p2] = [this.slowPromise(val), this.__timeoutPromise()];\n        let p = await Promise.all([p1, p2]);\n        v = p[0];\n        this.resolved = true;\n        v && (this.slow = v);\n      } else {\n        v = await this.slowPromise(val);\n        this.resolved = true;\n        v && (this.slow = v);\n      }\n    }\n  }\n\n  // helper to enforce fps minimum\n  async __timeoutPromise() {\n    // console.log('calling TO');\n    return new Promise((resolve, reject) => {\n      setTimeout(resolve, 1000 / this.fps);\n    }).then(() => {\n      // console.log('resolved TO');\n      return null;\n    });\n  }\n}\n","//   // step size range [0,1] (percent of total dist)\nfunction stepToward(prevPos, actualPos, stepSize = 0.1) {\n  let x, y;\n  let [x1, y1] = [...prevPos];\n  let [x2, y2] = [...actualPos];\n\n  let d_x = x2 - x1;\n  let d_y = y2 - y1;\n\n  x = x1 + d_x * stepSize;\n  y = y1 + d_y * stepSize;\n  return [x, y];\n}\n\nfunction stepTowardLinear(prevVal, actualVal, stepSize = 0.1) {\n  let d_x = actualVal - prevVal;\n\n  return prevVal + d_x * stepSize;\n}\n\nfunction averageCoordinate(array) {\n  let l = array.length;\n  let c = array\n    .reduce(\n      (acc, curr) => {\n        let [x, y, z] = acc;\n        let [xc, yc, zc] = curr;\n        return [x + xc, y + yc, z + zc];\n      },\n      [0, 0, 0]\n    )\n    .map((v) => v / l);\n  return c;\n}\n\nfunction distanceCoordinates(c1, c2) {\n  if (c1.length === 2) {\n    return Math.sqrt((c2[0] - c1[0]) ** 2 + (c2[1] - c1[1]) ** 2);\n  } else if (c1.length === 3) {\n    return Math.sqrt(\n      (c2[0] - c1[0]) ** 2 + (c2[1] - c1[1]) ** 2 + (c2[2] - c1[2]) ** 2\n    );\n  } else {\n    throw new Error('please enter 2d or 3d vectors');\n  }\n}\n\n// This maths is absolutely terrible\nfunction angleCoordinatesXY(c1, c2) {\n  let [x1, y1] = c1;\n  let [x2, y2] = c2;\n  let d_x = x2 - x1;\n  let d_y = y2 - y1;\n  let angle = Math.atan(d_y / d_x);\n  let a;\n  a = angle < 0 ? angle + Math.PI : angle;\n  return Math.PI - a;\n}\n\nexport {\n  stepToward,\n  stepTowardLinear,\n  averageCoordinate,\n  distanceCoordinates,\n  angleCoordinatesXY,\n};\n","import { mergeDeep } from './../helpers/helpers';\nimport Interpolator from './Interpolator';\nimport { defaults } from '../defaults';\n\n//\n\n// params\n// detector: a detector with load, detect and configure function\n// configs: e.g. :\n\nexport default class InterpolatedDetectorMULTI {\n  constructor(detectors) {\n    // {noser: {detector: NVDDetector(class), config:{}}, mesh: {detector: NVDDetector(class), config:{}}, etc }\n    this.detectors = detectors;\n    this.loaded = false;\n    this.animationFrameId = null;\n  }\n\n  async load() {\n    let promises = [];\n    Object.values(this.detectors).forEach((d) => {\n      // Load the models\n      promises.push(d.detector.load());\n      // await d.detector.load();\n\n      // Add the interpolators\n      d.interpolator = new Interpolator(\n        (video) => d.detector.detect(video), //slow fn to interpolate between return vals\n        d.config.interpolator.stepToward, //interpolation fn\n        d.config.interpolator.sensitivity,\n        d.config.interpolator.fps\n      );\n    });\n    let p = await Promise.all(promises);\n    console.log('all loaded');\n    this.loaded = true;\n  }\n\n  configure(configs) {\n    let detNames = Object.keys(configs);\n    detNames.forEach((d) => {\n      // get detector\n      let dd = this.detectors[d];\n      // configure the detector if config\n      if (configs[d].detector) {\n        this.__configureDetector(configs[d].detector, dd);\n      }\n      // configure the interpolator if config\n      if (configs[d].interpolator) {\n        this.__configureInterpolator(configs[d].interpolator, dd);\n      }\n    });\n  }\n\n  // probably bad naming -  actually calls the interpolators (which in turn call the detect fn of detectors as their 'slow' promise)\n  detect(video) {\n    if (!this.loaded) {\n      return {};\n    }\n    let detections = {};\n    Object.keys(this.detectors).forEach((n) => {\n      detections[n] = this.detectors[n].interpolator.interpolate(video);\n    });\n\n    // let configs = Object.values({ ...this.detectors }).map((v) => v.config);\n    let configs = {};\n    Object.keys(this.detectors).forEach((n) => {\n      configs[n] = this.detectors[n].config;\n    });\n\n    return { detections, configs };\n  }\n\n  // looping detection\n  startDetection(video, loopers = []) {\n    const looper = () => {\n      this.detect(video);\n      //loop any functions hooking into the animation loop\n      if (loopers.length) {\n        loopers.forEach((fn) => fn());\n      }\n      this.animationFrameId = requestAnimationFrame(looper);\n    };\n    looper();\n  }\n\n  stopDetection() {\n    cancelAnimationFrame(this.animationFrameId);\n  }\n  __configureDetector(config, detector = {}) {\n    Object.assign(detector.config.detector, config);\n\n    detector.detector.configure(config);\n  }\n\n  // interpolator don't (yet?) have config option so need to instantiate new one\n  __configureInterpolator(config, detector = {}) {\n    Object.assign(detector.config.interpolator, config);\n\n    detector.interpolator = new Interpolator(\n      (video) => detector.detector.detect(video),\n      detector.config.interpolator.stepToward,\n      detector.config.interpolator.sensitivity,\n      detector.config.interpolator.fps\n    );\n  }\n}\n\n// mergeDeep of default configs should be in index.js, not here - > the input should already be a complete config object\n// config fn should compare existing configs and new ones. and only update if the key for that detector is in configure fn call object\nclass InterpolatedDetector {\n  constructor(configs, detector) {\n    this.detector = detector;\n    this.interpolator = null;\n    this.configs = mergeDeep({}, defaults, configs);\n    // note : current implementation in react always provides a complete configuration object (mergeDeep alrady done)\n    // reason: react needs to hold the config state so that sliders etc work\n    // so  merge isnt really needed here (currently\n  }\n\n  async load() {\n    // load and set up detector\n    await this.detector.load();\n    this.__configureDetector(this.configs.detector);\n\n    //config inits new interpolator (sets this.interpolator = ...)\n    this.__configureInterpolator(this.configs.interpolator);\n  }\n\n  configure(configuration) {\n    // only update configurations which have changed: (slightly smoother UI when configuring)\n    //*\n\n    /** TODO This function can be simplified\n     * only configure detector/interp if it exists in input\n     * (no need for deep conpare-?) - assumes any input is different...\n     */\n    let detectorConfigChange =\n      JSON.stringify(this.configs.detector) !==\n      JSON.stringify(configuration.detector);\n\n    let interpolatorConfigChange =\n      JSON.stringify(this.configs.interpolator) !==\n      JSON.stringify(configuration.interpolator);\n\n    //configure detector\n    detectorConfigChange && this.__configureDetector(configuration.detector);\n\n    // init new interpolator (with new configuration)\n    interpolatorConfigChange &&\n      this.__configureInterpolator(configuration.interpolator);\n\n    //update configs\n    this.configs = mergeDeep({}, this.configs, configuration);\n  }\n\n  __configureDetector(config) {\n    this.detector.configure(config);\n  }\n  __configureInterpolator(config) {\n    this.interpolator = new Interpolator(\n      (video) => this.detector.detect(video),\n      config.stepToward,\n      config.sensitivity,\n      config.fps\n    );\n  }\n\n  detect(video) {\n    return this.interpolator.interpolate(video);\n  }\n}\n","const FACE_SCALE = 85;\nconst HAND_SCALE = 1; // currently unused?\nexport { FACE_SCALE, HAND_SCALE };\n","  import { FACE_SCALE } from '../../constants';\n\nexport default class VectorDetector {\n  constructor(config) {\n    this.model = null;\n    this.config = config; // optional - can be configured after init\n  }\n\n  // load, detect and __getPredictionData are in extensions of this class\n\n  configure(config) {\n    Object.assign(this.config, config);\n    //\n  }\n\n  // TODO: move this to face classes (or a shared class for all face classes? - which blaze/mesh inherit from)\n  __getNosePointVectors(nose, center, scale = 1) {\n    let central_bounding = this.config.central_bounding;\n    let outer_bounding = this.config.outer_bounding;\n\n    const x = center[0] - nose[0];\n    const y = center[1] - nose[1];\n    let coords = [x, y];\n\n    //normalize distance\n\n    // -----------------------------------------------------------\n\n    const direction_word = this.__getDirection(coords, central_bounding);\n    const vector = [x, y];\n\n    // TODO - should outerbounding be scaled separately?\n    const nose_normalized_square = this.__getVectorNormalized(\n      coords, //px\n      outer_bounding, //px\n      scale //px used to grow/shrink bounding limits based on z distance\n    );\n    const nose_normalized_circle = this.__normalizeRect2Circ(\n      nose_normalized_square\n    );\n\n    return {\n      direction_word,\n      vector, //absolute value in face bounding rect\n      nose_normalized_square, //normalized square [0,1]x [0,1]y\n      nose_normalized_circle, //normalized circle [0,1]r\n    };\n  }\n\n  __normalizeInRange(value, range1, range2 = [0, 1]) {\n    if (value > range1[1]) {\n      return range2[1];\n    }\n    if (value < range1[0]) {\n      return range2[0];\n    }\n    let dist1 = range1[1] - range1[0];\n    let dist2 = range2[1] - range2[0];\n\n    const ratio = (value - range1[0]) / dist1; //range [0,1]\n    let norm = range2[0] + ratio * dist2;\n    return norm;\n  }\n\n  //2d plane coordinates => unit circle r=1.\n  // note: not a map but simply limits coordinates outside of radius to on circle.\n  __normalizeRect2Circ(coords, radius = 1) {\n    let [x, y] = coords;\n    let x_sign = x > 0 ? 1 : -1;\n    let y_sign = y > 0 ? 1 : -1;\n\n    if (Math.sqrt(x ** 2 + y ** 2) <= radius) {\n      return [x, y];\n    }\n\n    const theta = Math.atan(y / x);\n    const y_b = y_sign * Math.abs(radius * Math.sin(theta));\n    const x_b = x_sign * Math.abs(radius * Math.cos(theta));\n    return [x_b, y_b];\n  }\n\n  // TODO rename/mvoe to blaze/mesh class\n  // returns \"up\", \"down\",\"left\",\"right\"\n  __getDirection(coords, central_bounding) {\n    const [x, y] = coords;\n\n    let direction;\n    // get bounding config\n    let bounding_x = central_bounding.x;\n    let bounding_y = central_bounding.y;\n    let [x_min, x_max] = bounding_x;\n    let [y_min, y_max] = bounding_y;\n\n    // estimate direction\n    if (x <= x_max && x >= x_min && y <= y_max && y >= y_min) {\n      direction = 'center';\n    } else if (x < x_max && x > x_min) {\n      if (y > y_max) {\n        direction = 'up';\n      } else if (y < y_min) {\n        direction = 'down';\n      }\n    } else if (y < y_max && y > y_min) {\n      if (x > x_max) {\n        direction = 'right';\n      } else if (x < x_min) {\n        direction = 'left';\n      }\n    }\n    return direction;\n  }\n\n  //TODO is this needed in this form? // maybe it is good for stuff with 2d bounding..?\n  // where are the scaling operations happening?\n  __getVectorNormalized(coords, outer_bounding, scale = 1) {\n    const [x, y] = coords;\n\n    // get bounding config\n    let bounding_x = outer_bounding.x.map((v) => v * scale); //z axis normalization;\n    let bounding_y = outer_bounding.y.map((v) => v * scale); //z axis normalization;\n    let [x_min, x_max] = bounding_x;\n    let [y_min, y_max] = bounding_y;\n\n    let x_normalized = this.__normalizeInRange(x, [x_min, x_max], [-1, 1]); // range normalization\n    let y_normalized = this.__normalizeInRange(y, [y_min, y_max], [-1, 1]);\n\n    return [x_normalized, y_normalized];\n  }\n}\n","\n\nimport * as faceLandmarksDetection from '@tensorflow-models/face-landmarks-detection';\n\n\nimport { distanceCoordinates } from '../../helpers/geometry';\nimport { FACE_SCALE } from '../../constants';\n\nimport './__VectorDetector';\nimport VectorDetector from './__VectorDetector';\n\nexport default class NVDMesh extends VectorDetector {\n  constructor(config) {\n    super(config);\n    // super(config);\n    // this.model = model;\n  }\n\n  async load() {\n    this.model = await faceLandmarksDetection.load(\n      faceLandmarksDetection.SupportedPackages.mediapipeFacemesh,\n      { maxFaces: 1, shouldLoadIrisModel: false }\n    );\n  }\n\n  async detect(video) {\n    // Get predictions from model\n    let predictions = await this.model.estimateFaces({\n      input: video,\n      predictIrises: false,\n    });\n\n    if (!predictions.length) {\n      return false;\n    }\n\n    // Extract relevant data\n    let data = this.__getPredictionData(predictions[0]);\n    const { scale } = data;\n    const { center } = data.face;\n    const {\n      rightEyeLower1,\n      rightEyeUpper1,\n      leftEyeLower1,\n      leftEyeUpper1,\n    } = data.eyes;\n    const { lipsLowerInner, lipsUpperInner } = data.mouth;\n    const { tip } = data.nose;\n\n    // Calculate vectors\n    let noseVectors = this.__getNosePointVectors(tip, center, scale);\n    let mouthVector = this.__getMouthOpenVector(\n      lipsLowerInner,\n      lipsUpperInner,\n      scale\n    );\n    let eyeVectors = this.__getEyesClosedVectors(\n      rightEyeLower1,\n      rightEyeUpper1,\n      leftEyeLower1,\n      leftEyeUpper1,\n      scale\n    );\n\n    let vectors = {\n      ...noseVectors,\n      ...mouthVector,\n      ...eyeVectors,\n    };\n    // let config = this.config;\n\n    // Return info\n\n    // return int_vectors = vectors for first loop\n    return { int_vectors: vectors, vectors, data, predictions: predictions[0] }; // not 'raw' data (predictions also included) data is kinda a shit dupe of this? (but useful for us here/.)\n  }\n\n  // Extract useful data from raw data\n  __getPredictionData(prediction) {\n    //face\n    const { topLeft, bottomRight } = prediction.boundingBox;\n    const width = bottomRight[0] - topLeft[0];\n    const height = bottomRight[1] - topLeft[1];\n    const center = [topLeft[0] + width / 2, topLeft[1] + height / 2];\n\n    let {\n      lipsLowerInner,\n      lipsUpperInner,\n      rightEyeLower1,\n      rightEyeUpper1,\n      leftEyeLower1,\n      leftEyeUpper1,\n    } = prediction.annotations;\n\n    lipsLowerInner = lipsLowerInner[5];\n    lipsUpperInner = lipsUpperInner[5];\n    rightEyeLower1 = rightEyeLower1[4];\n    rightEyeUpper1 = rightEyeUpper1[4];\n    leftEyeLower1 = leftEyeLower1[4];\n    leftEyeUpper1 = leftEyeUpper1[4];\n\n    const eyeDist = distanceCoordinates(rightEyeLower1, leftEyeLower1);\n    const noseTip = prediction.scaledMesh[4];\n    const scale = eyeDist / FACE_SCALE;\n    return {\n      scale,\n      face: { topLeft, bottomRight, width, height, center },\n      eyes: {\n        rightEyeLower1,\n        rightEyeUpper1,\n        leftEyeLower1,\n        leftEyeUpper1,\n        eyeDist,\n      },\n      nose: {\n        tip: noseTip,\n      },\n      mouth: { lipsLowerInner, lipsUpperInner },\n    };\n    // return {\n    //   topLeft,\n    //   bottomRight,\n    //   width,\n    //   height,\n    //   center,\n    //   nose,\n    //   lipsLowerInner,\n    //   lipsUpperInner,\n    //   rightEyeLower1,\n    //   rightEyeUpper1,\n    //   leftEyeLower1,\n    //   leftEyeUpper1,\n    //   eyeDist,\n    //   scale,\n    // };\n  }\n\n  __getMouthOpenVector(lipUpper, lipLower, scale) {\n    let distance = distanceCoordinates(lipUpper, lipLower) / scale; // z normalized\n    let mouth_bounding = this.config.mouth_bounding;\n    const normalized_mouth = this.__normalizeInRange(distance, mouth_bounding);\n\n    return { normalized_mouth };\n  }\n  //output is a bit shit but that the model not the fn\n  __getEyesClosedVectors(\n    rightEyeLower1,\n    rightEyeUpper1,\n    leftEyeLower1,\n    leftEyeUpper1,\n    scale\n  ) {\n    let distance_r =\n      distanceCoordinates(rightEyeLower1, rightEyeUpper1) / scale; //distance normalized for z-dist\n    let eye_bounding = this.config.eye_bounding;\n    const normalized_eye_r = this.__normalizeInRange(distance_r, eye_bounding);\n    let distance_l = distanceCoordinates(leftEyeLower1, leftEyeUpper1) / scale; //distance normalized for z-dist\n\n    const normalized_eye_l = this.__normalizeInRange(distance_l, eye_bounding);\n\n    return { normalized_eye_r, normalized_eye_l };\n  }\n}\n","import * as faceLandmarksDetection from '@tensorflow-models/face-landmarks-detection';\n\nimport './__VectorDetector';\nimport VectorDetector from './__VectorDetector';\n\n// TODO extends Mesh\n\nexport default class IVDMesh extends VectorDetector {\n  constructor(config) {\n    super( config);\n  }\n\n  async load() {\n    this.model = await faceLandmarksDetection.load(\n      faceLandmarksDetection.SupportedPackages.mediapipeFacemesh,\n      { maxFaces: 1, shouldLoadIrisModel: true }\n    );\n  }\n\n  async detect(video) {\n    // Get predictions from model\n    let predictions = await this.model.estimateFaces({\n      input: video,\n      predictIrises: true,\n    });\n    if (!predictions.length) {\n      return false;\n    }\n\n    // Extract relevant data\n    const { nose, center } = this.__getPredictionData(predictions[0]);\n\n    let vectors = this.__getNosePointVectors(nose, center);\n    let config = this.config;\n\n    // note estimateFaces complete *predictions* are also included here (DO NOT call it again!)\n    return { vectors, predictions: predictions[0] };\n  }\n\n  __getPredictionData(prediction) {\n    let annots = prediction.annotations;\n\n    let {\n      leftEyeIris,\n      leftEyeLower0,\n      leftEyeLower1,\n      leftEyeLower2,\n      leftEyeLower3,\n      leftEyeUpper0,\n      leftEyeUpper1,\n      leftEyeUpper2,\n    } = annots;\n\n    let pts = [\n      ...leftEyeLower0,\n      // ...leftEyeLower1,\n      // ...leftEyeLower2,\n      // ...leftEyeLower3,\n      ...leftEyeUpper0,\n      // ...leftEyeUpper1,\n      // ...leftEyeUpper2,\n    ];\n    //find average (central point)\n    let l = pts.length;\n    let c = pts\n      .reduce(\n        (acc, curr, i, a) => {\n          let [x, y] = acc;\n          let [xc, yc] = curr;\n          return [x + xc, y + yc];\n        },\n        [0, 0]\n      )\n      .map((v) => v / l);\n\n    // const topLeft = prediction.topLeft;\n    // const bottomRight = prediction.bottomRight;\n    // const width = bottomRight[0] - topLeft[0];\n    // const height = bottomRight[1] - topLeft[1];\n    // const center = [topLeft[0] + width / 2, topLeft[1] + height / 2];\n\n    // const nose = prediction.landmarks[2];\n\n    const nose = leftEyeIris[0]; //not nose..\n    const center = c;\n\n    return { center, nose };\n  }\n}\n","import * as handpose from '@tensorflow-models/handpose';\nimport {\n  distanceCoordinates,\n  angleCoordinatesXY,\n  averageCoordinate,\n} from '../../helpers/geometry';\nimport { HAND_SCALE } from '../../constants';\n\nimport './__VectorDetector';\nimport VectorDetector from './__VectorDetector';\n\nexport default class VDHandpose extends VectorDetector {\n  constructor(config) {\n    super(config);\n    // super(config);\n    // this.model = model;\n  }\n\n  async load() {\n    this.model = await handpose.load();\n  }\n\n  async detect(video) {\n    // Get predictions from model\n    const predictions = await this.model.estimateHands(\n      document.querySelector('video')\n    );\n\n    if (!predictions.length) {\n      return false;\n    }\n\n    // Extract relevant data\n    let data = this.__getPredictionData(predictions[0]);\n\n    // const { center ,width, height} = data;\n    let { indexFinger, middleFinger, palmBase, pink, ringFinger, thumb } = data;\n    let finger1Tip = indexFinger[3];\n    let thumbTip = thumb[3];\n\n    // Calculate vectors\n\n    let pinchPos1 = this.__getPinchPos(thumbTip, finger1Tip, 1);\n\n    let pinch1 = this.__getPinchVector(\n      thumbTip,\n      finger1Tip,\n      this.config.pinch1_bounding,\n      1\n    );\n    //assuming right hand for direction of rotation though no so important\n    let rotation1 = this.__getRotation(\n      thumbTip,\n      finger1Tip,\n      this.config.rotation1_bounding,\n      1\n    );\n\n    let vectors = { pinch1, rotation1, pinchPos1 };\n    // let config = this.config;\n\n    // Return info\n\n    // return int_vectors = vectors for first loop\n    return { int_vectors: vectors, vectors, data, predictions: predictions[0] }; // not 'raw' data (predictions also included) data is kinda a shit dupe of this? (but useful for us here/.)\n  }\n\n  // Extract useful data from raw data\n  __getPredictionData(prediction) {\n    //face\n    const { topLeft, bottomRight } = prediction.boundingBox;\n    const width = bottomRight[0] - topLeft[0];\n    const height = bottomRight[1] - topLeft[1];\n    const center = [topLeft[0] + width / 2, topLeft[1] + height / 2];\n\n    // const scale = eyeDist / FACE_SCALE;\n    return { topLeft, width, height, center, ...prediction.annotations };\n  }\n  // should be a more general fn\n\n  // normalized [0,1]\n  __getPinchPos(thumbTip, finger1Tip, pinchBounding, scale) {\n    const dims = [640, 480];\n\n    let p = averageCoordinate([thumbTip, finger1Tip]);\n    let norm = [p[0] / dims[0], p[1] / dims[1]];\n    return norm;\n  }\n\n  __getPinchVector(thumbTip, finger1Tip, pinchBounding, scale) {\n    let distance = distanceCoordinates(thumbTip, finger1Tip) / scale; // z normalized\n    const normalizedPinch = this.__normalizeInRange(distance, pinchBounding);\n    return normalizedPinch;\n  }\n\n  __getRotation(thumbTip, finger1Tip, rotationBounding, scale) {\n    let angle;\n    let distance = distanceCoordinates(thumbTip, finger1Tip) / scale; // z normalized\n    if (distance < rotationBounding[0] || distance > rotationBounding[1]) {\n      return null;\n    }\n    angle = angleCoordinatesXY(thumbTip, finger1Tip);\n\n    return angle;\n  }\n\n  //output is a bit shit but that the model not the fn\n}\n","// Presets for FaceDetector class\n\nimport { stepToward, stepTowardLinear } from './helpers/geometry';\n\n// measured in pixels where eyes are FACE_SCALE (constant) distance apart\n// scaled for z distance in calculations\n// TO DO: set as [0,1] - width/height of full capture\nconst defaultsMULTI = {\n  blaze: {\n    detector: {\n      central_bounding: { x: [-20, 20], y: [-20, 15] },\n      outer_bounding: { x: [-50, 50], y: [-35, 15] },\n    },\n    interpolator: {\n      fps: 0, // zero is max\n      sensitivity: 0.07,\n      stepToward: stepTowardDetector,\n    },\n  },\n  mesh: {\n    detector: {\n      central_bounding: { x: [-20, 20], y: [-20, 15] },\n      outer_bounding: { x: [-50, 50], y: [-35, 15] },\n      mouth_bounding: [0, 25],\n      eye_bounding: [20, 32],\n    },\n    interpolator: {\n      fps: 0, // zero is gives a max fps\n      sensitivity: 0.07,\n      stepToward: stepTowardDetector,\n    },\n  },\n  iris: {\n    detector: {\n      central_bounding: { x: [-20, 20], y: [-20, 15] },\n      outer_bounding: { x: [-50, 50], y: [-35, 15] },\n      mouth_bounding: [0, 10],\n      eye_bounding: [25, 32],\n    },\n    interpolator: {\n      fps: 0, // zero is max\n      sensitivity: 0.07,\n      stepToward: stepTowardDetector,\n    },\n  },\n  handpose: {\n    detector: {\n      central_bounding: { x: [-20, 20], y: [-20, 15] },\n      outer_bounding: { x: [-50, 50], y: [-35, 15] },\n      pinch1_bounding: [50, 150],\n      rotation1_bounding: [100, 200], //rotation not registered outside of this dist betw fingers\n\n      pinch2_bounding: [50, 150],\n      pinch3_bounding: [50, 150],\n      pinch4_bounding: [50, 150],\n    },\n    interpolator: {\n      fps: 0, // zero is max\n      sensitivity: 0.25,\n      stepToward: handposeStepTowardDetector,\n    },\n  },\n};\n\n// only change circle/square vectors\n\n// TODO: a method that has [\"vector-normalized-cicle\",\"vector-normalized-square\"] as argument instead of this object madness\nfunction stepTowardDetector(prevPredictions, currentPredictions, sensitivity) {\n  const { vectors } = currentPredictions;\n  const {\n    nose_normalized_circle,\n    nose_normalized_square,\n    normalized_mouth,\n  } = vectors;\n\n  return {\n    ...currentPredictions,\n    // ...vectors,\n    int_vectors: {\n      nose_normalized_circle: stepToward(\n        prevPredictions.int_vectors?.nose_normalized_circle ||\n          prevPredictions.vectors.nose_normalized_circle, //first iteration this object does not exist\n        nose_normalized_circle,\n        sensitivity\n      ),\n      nose_normalized_square: stepToward(\n        prevPredictions.int_vectors?.nose_normalized_square ||\n          prevPredictions.vectors.nose_normalized_square,\n        nose_normalized_square,\n        sensitivity\n      ),\n      normalized_mouth: stepTowardLinear(\n        prevPredictions.int_vectors?.normalized_mouth ||\n          prevPredictions.vectors.normalized_mouth,\n\n        normalized_mouth,\n        sensitivity\n      ),\n    },\n  };\n}\n\nfunction handposeStepTowardDetector(\n  prevPredictions,\n  currentPredictions,\n  sensitivity\n) {\n  const { vectors } = currentPredictions;\n  const { pinch1, rotation1, pinchPos1 } = vectors;\n\n  return {\n    ...currentPredictions,\n    // ...vectors,\n    int_vectors: {\n      pinch1: stepTowardLinear(\n        prevPredictions.int_vectors?.pinch1 || prevPredictions.vectors.pinch1,\n        pinch1,\n        sensitivity\n      ),\n      pinchPos1: stepToward(\n        prevPredictions.int_vectors?.pinchPos1 ||\n          prevPredictions.vectors.pinchPos1,\n        pinchPos1,\n        sensitivity\n      ),\n      rotation1: stepTowardLinear(\n        prevPredictions.int_vectors?.rotation1 ||\n          prevPredictions.vectors.rotation1,\n        rotation1,\n        sensitivity\n      ),\n    },\n  };\n}\n\nexport { defaultsMULTI };\n","import * as tf from '@tensorflow/tfjs-core';\nimport '@tensorflow/tfjs-backend-webgl';\n// import * as tfjsWasm from '@tensorflow/tfjs-backend-wasm';\n// import '@tensorflow/tfjs-backend-cpu';\n// not using tf.setBackend ..\n\nimport InterpolatedDetector from './classes/InterpolatedDetector';\nimport VectorDetector from './classes/Detectors/__VectorDetector';\n// import NVDBlaze from './classes/Detectors/VDBlaze';\nimport NVDMesh from './classes/Detectors/VDMesh';\nimport IVDMesh from './classes/Detectors/VDIrisMesh';\nimport VDHandpose from './classes/Detectors/VDHandpose';\n// import { op } from '@tensorflow/tfjs';\n// import { defaults } from './defaults';\nimport { defaultsMULTI } from './defaultsMULTI';\nimport { mergeDeep } from './helpers/helpers';\n\n// MULTI - args: [{name: \"blaze\", config:{asdf}, \"mesh\"] ; args array contains either object (with configs) OR string (default configs)\n// config here! i.e.- new IVDMesh(configs)  - merge with defaults so that vectorDetector always has full config\n\nexport default function nosePoseMULTI(options = []) {\n  let detectors = {};\n  // {blaze: {detector: NVDDetector(class), config:{detector:{}, interpolator:{}}}, mesh: {detector: NVDDetector(class), config:{}}, etc }\n\n  options.forEach((option) => {\n    let d;\n    if (typeof option === 'string') {\n      d = getDetector(option, null);\n      let name = option;\n      detectors[name] = d;\n    } else {\n      let name = option.name;\n      d = getDetector(name, option.config);\n      detectors[name] = d;\n    }\n  });\n\n  let smoothDetector = new InterpolatedDetector(detectors);\n  return smoothDetector;\n}\n\n/**\n *\n * @param {name\n * } type string\n */\nasync function getDetector(name, config) {\n  let detector;\n  // add in configs that haven't been specified\n  let configMerged = mergeDeep({}, defaultsMULTI[name], config);\n\n  switch (name) {\n    case 'iris':\n      detector = new IVDMesh(configMerged.detector);\n      break;\n    case 'mesh':\n      detector = new NVDMesh(configMerged.detector);\n      break;\n    case 'blaze':\n      let NVDBlaze = await import('./classes/Detectors/VDBlaze');\n\n      detector = new NVDBlaze(configMerged.detector);\n      break;\n    case 'handpose':\n      detector = new VDHandpose(configMerged.detector);\n      break;\n    default:\n      //none\n      // detector = new NVDBlaze(configMerged.detector);\n\n      break;\n  }\n  // add configs that are not supplied\n\n  // return detector object\n  return { detector, config: configMerged };\n}\n"],"names":["isObject","item","Array","isArray","mergeDeep","target","sources","length","source","shift","key","Object","assign","Interpolator","slowPromise","stepToward","stepArg","fps","this","fast","slow","resolved","interpolate","val","__updateFast","__updateSlow","_this2","v","__timeoutPromise","Promise","all","p","resolve","reject","setTimeout","_this4","then","prevPos","actualPos","stepSize","x1","y1","stepTowardLinear","prevVal","actualVal","distanceCoordinates","c1","c2","Math","sqrt","Error","InterpolatedDetectorMULTI","detectors","loaded","animationFrameId","load","promises","values","forEach","d","push","detector","interpolator","video","detect","config","sensitivity","console","log","configure","configs","keys","dd","_this3","__configureDetector","__configureInterpolator","detections","n","startDetection","loopers","looper","_this5","fn","requestAnimationFrame","stopDetection","cancelAnimationFrame","FACE_SCALE","VectorDetector","model","__getNosePointVectors","nose","center","scale","outer_bounding","x","y","coords","direction_word","__getDirection","central_bounding","vector","nose_normalized_square","__getVectorNormalized","nose_normalized_circle","__normalizeRect2Circ","__normalizeInRange","value","range1","range2","radius","x_sign","y_sign","theta","atan","y_b","abs","sin","cos","direction","bounding_x","bounding_y","x_min","x_max","y_min","y_max","map","NVDMesh","faceLandmarksDetection","mediapipeFacemesh","maxFaces","shouldLoadIrisModel","estimateFaces","input","predictIrises","predictions","data","__getPredictionData","eyes","rightEyeLower1","rightEyeUpper1","leftEyeLower1","leftEyeUpper1","mouth","lipsLowerInner","lipsUpperInner","vectors","tip","face","__getMouthOpenVector","__getEyesClosedVectors","int_vectors","prediction","boundingBox","topLeft","bottomRight","width","height","annotations","eyeDist","scaledMesh","lipUpper","lipLower","distance","normalized_mouth","mouth_bounding","distance_r","eye_bounding","normalized_eye_r","distance_l","normalized_eye_l","IVDMesh","annots","leftEyeIris","pts","leftEyeLower0","leftEyeUpper0","l","reduce","acc","curr","i","a","VDHandpose","handpose","estimateHands","document","querySelector","finger1Tip","indexFinger","thumbTip","thumb","pinchPos1","__getPinchPos","pinch1","__getPinchVector","pinch1_bounding","rotation1","__getRotation","rotation1_bounding","pinchBounding","array","dims","rotationBounding","angle","PI","defaultsMULTI","blaze","stepTowardDetector","mesh","iris","pinch2_bounding","pinch3_bounding","pinch4_bounding","prevPredictions","currentPredictions","_settle","pact","state","s","_Pact","o","bind","observer","getDetector","name","configMerged","discriminant","cases","awaitBody","dispatchIndex","outer","test","testValue","body","result","fallthroughCheck","_resumeAfterBody","_resumeAfterTest","import","NVDBlaze","prototype","onFulfilled","onRejected","callback","e","_this","nosePoseMULTI","options","option","InterpolatedDetector"],"mappings":"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"}