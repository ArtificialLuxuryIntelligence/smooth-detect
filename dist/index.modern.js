import"@tensorflow/tfjs-core";import"@tensorflow/tfjs-backend-webgl";import"@tensorflow/tfjs-backend-cpu";import{load as t}from"@tensorflow-models/blazeface";import{load as e,SupportedPackages as r}from"@tensorflow-models/face-landmarks-detection";import{load as o}from"@tensorflow-models/handpose";function n(t){return t&&"object"==typeof t&&!Array.isArray(t)}function i(t,...e){if(!e.length)return t;const r=e.shift();if(n(t)&&n(r))for(const e in r)n(r[e])?(t[e]||Object.assign(t,{[e]:{}}),i(t[e],r[e])):Object.assign(t,{[e]:r[e]});return i(t,...e)}class s{constructor(t,e,r=!1){this.slowPromise=t,this.stepToward=e,this.fast=null,this.slow=null,this.resolved=!0,this.fps=r}interpolate(t){return this.__updateSlow(t),this.__updateFast(),this.fast}__updateFast(){this.fast=this.fast?this.stepToward(this.fast,this.slow):this.slow}async __updateSlow(t){if(this.resolved&&this.resolved){let e;if(this.resolved=!1,this.fps){const[r,o]=[this.slowPromise(t),this.__timeoutPromise()];e=(await Promise.all([r,o]))[0],this.resolved=!0,e&&(this.slow=e)}else e=await this.slowPromise(t),this.resolved=!0,e&&(this.slow=e)}}async __timeoutPromise(){return new Promise((t,e)=>{setTimeout(t,1e3/this.fps)}).then(()=>null)}}function a(){return(a=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var r=arguments[e];for(var o in r)Object.prototype.hasOwnProperty.call(r,o)&&(t[o]=r[o])}return t}).apply(this,arguments)}function c(t,e){if(2===t.length)return Math.sqrt((e[0]-t[0])**2+(e[1]-t[1])**2);if(3===t.length)return Math.sqrt((e[0]-t[0])**2+(e[1]-t[1])**2+(e[2]-t[2])**2);throw new Error("please enter 2d or 3d vectors")}function l(t,e,r=.1){let o,n,[i,s]=[...t],[a,c]=[...e];return o=i+(a-i)*r,n=s+(c-s)*r,[o,n]}class h{constructor(t){this.detectors=t,this.loaded=!1,this.animationFrameId=null}async load(){let t=[];Object.values(this.detectors).forEach(e=>{t.push(e.detector.load());const{stepperFactory:r,mapperArgs:o,fps:n}=e.config.interpolator,i=r(o);e.interpolator=new s(t=>e.detector.detect(t),i,n)}),await Promise.all(t),console.log("all loaded"),this.loaded=!0}configure(t){Object.keys(t).forEach(e=>{let r=this.detectors[e];t[e].detector&&this.__configureDetector(t[e].detector,r),t[e].interpolator&&this.__configureInterpolator(t[e].interpolator,r)})}detect(t){if(!this.loaded)return{};let e={};Object.keys(this.detectors).forEach(r=>{e[r]=this.detectors[r].interpolator.interpolate(t)});let r={};return Object.keys(this.detectors).forEach(t=>{r[t]=this.detectors[t].config}),{detections:e,configs:r}}startDetection(t,e=[]){const r=()=>{let o=this.detect(t);e.length&&e.forEach(t=>t(o)),this.animationFrameId=requestAnimationFrame(r)};r()}stopDetection(){cancelAnimationFrame(this.animationFrameId)}__configureDetector(t,e={}){Object.assign(e.config.detector,t),e.detector.configure(t)}__configureInterpolator(t,e={}){i(e.config.interpolator,t);const{stepperFactory:r,mapperArgs:o,fps:n}=e.config.interpolator,a=r(o);e.interpolator=new s(t=>e.detector.detect(t),a,n)}}class d{constructor(t){this.model=null,this.config=t}configure(t){Object.assign(this.config,t)}__getNosePointVectors(t,e,r=1){let o=this.config.outer_bounding;const n=e[0]-t[0],i=e[1]-t[1];let s=[n,i];const a=this.__getDirection(s,this.config.central_bounding),c=[n,i],l=this.__getVectorNormalized(s,o,r);return{direction_word:a,vector:c,nose_normalized_square:l,nose_normalized_circle:this.__normalizeRect2Circ(l)}}__normalizeInRange(t,e,r=[0,1]){return t>e[1]?r[1]:t<e[0]?r[0]:r[0]+(t-e[0])/(e[1]-e[0])*(r[1]-r[0])}__normalizeRect2Circ(t,e=1){let[r,o]=t,n=r>0?1:-1,i=o>0?1:-1;if(Math.sqrt(r**2+o**2)<=e)return[r,o];const s=Math.atan(o/r),a=i*Math.abs(e*Math.sin(s));return[n*Math.abs(e*Math.cos(s)),a]}__getDirection(t,e){const[r,o]=t;let n,i=e.x,s=e.y,[a,c]=i,[l,h]=s;return r<=c&&r>=a&&o<=h&&o>=l?n="center":r<c&&r>a?o>h?n="up":o<l&&(n="down"):o<h&&o>l&&(r>c?n="right":r<a&&(n="left")),n}__getVectorNormalized(t,e,r=1){const[o,n]=t;let i=e.x.map(t=>t*r),s=e.y.map(t=>t*r),[a,c]=i,[l,h]=s;return[this.__normalizeInRange(o,[a,c],[-1,1]),this.__normalizeInRange(n,[l,h],[-1,1])]}}class p extends d{constructor(t){super(t)}async load(){this.model=await t({maxFaces:1})}async detect(t){let e=await this.model.estimateFaces(t);if(!e.length)return!1;let r=this.__getPredictionData(e[0]);const{scale:o}=r,{tip:n}=r.nose,{center:i}=r.face;return{vectors:this.__getNosePointVectors(n,i,o),predictions:e[0]}}__getPredictionData(t){const e=t.landmarks[2],r=c(t.landmarks[0],t.landmarks[1]),o=t.topLeft,n=t.bottomRight,i=n[0]-o[0],s=n[1]-o[1];return{scale:r/85,face:{topLeft:o,bottomRight:n,width:i,height:s,center:[o[0]+i/2,o[1]+s/2]},nose:{tip:e}}}}class u extends d{constructor(t){super(t)}async load(){this.model=await e(r.mediapipeFacemesh,{maxFaces:1,shouldLoadIrisModel:!1})}async detect(t){let e=await this.model.estimateFaces({input:t,predictIrises:!1});if(!e.length)return!1;let r=this.__getPredictionData(e[0]);const{scale:o}=r,{center:n}=r.face,{rightEyeLower1:i,rightEyeUpper1:s,leftEyeLower1:c,leftEyeUpper1:l}=r.eyes,{lipsLowerInner:h,lipsUpperInner:d}=r.mouth,{tip:p}=r.nose;let u=a({},this.__getNosePointVectors(p,n,o),this.__getMouthOpenVector(h,d,o),this.__getEyesClosedVectors(i,s,c,l,o));return{int_vectors:u,vectors:u,data:r,predictions:e[0]}}__getPredictionData(t){const{topLeft:e,bottomRight:r}=t.boundingBox,o=r[0]-e[0],n=r[1]-e[1],i=[e[0]+o/2,e[1]+n/2];let{lipsLowerInner:s,lipsUpperInner:a,rightEyeLower1:l,rightEyeUpper1:h,leftEyeLower1:d,leftEyeUpper1:p}=t.annotations;s=s[5],a=a[5],l=l[4],h=h[4],d=d[4],p=p[4];const u=c(l,d);return{scale:u/85,face:{topLeft:e,bottomRight:r,width:o,height:n,center:i},eyes:{rightEyeLower1:l,rightEyeUpper1:h,leftEyeLower1:d,leftEyeUpper1:p,eyeDist:u},nose:{tip:t.scaledMesh[4]},mouth:{lipsLowerInner:s,lipsUpperInner:a}}}__getMouthOpenVector(t,e,r){let o=c(t,e)/r;return{normalized_mouth:this.__normalizeInRange(o,this.config.mouth_bounding)}}__getEyesClosedVectors(t,e,r,o,n){let i=c(t,e)/n,s=this.config.eye_bounding;const a=this.__normalizeInRange(i,s);let l=c(r,o)/n;return{normalized_eye_r:a,normalized_eye_l:this.__normalizeInRange(l,s)}}}class _ extends d{constructor(t){super(t)}async load(){this.model=await e(r.mediapipeFacemesh,{maxFaces:1,shouldLoadIrisModel:!0})}async detect(t){let e=await this.model.estimateFaces({input:t,predictIrises:!0});if(!e.length)return!1;const{nose:r,center:o}=this.__getPredictionData(e[0]);return{vectors:this.__getNosePointVectors(r,o),predictions:e[0]}}__getPredictionData(t){let e=t.annotations,{leftEyeIris:r,leftEyeLower0:o,leftEyeUpper0:n}=e,i=[...o,...n],s=i.length;return{center:i.reduce((t,e,r,o)=>{let[n,i]=t,[s,a]=e;return[n+s,i+a]},[0,0]).map(t=>t/s),nose:r[0]}}}class g extends d{constructor(t){super(t)}async load(){this.model=await o()}async detect(t){const e=await this.model.estimateHands(document.querySelector("video"));if(!e.length)return!1;let r=this.__getPredictionData(e[0]),{indexFinger:o,thumb:n}=r,i=o[3],s=n[3],a=this.__getPinchPos(s,i,1),c={pinch1:this.__getPinchVector(s,i,this.config.pinch1_bounding,1),rotation1:this.__getRotation(s,i,this.config.rotation1_bounding,1),pinchPos1:a};return{int_vectors:c,vectors:c,data:r,predictions:e[0]}}__getPredictionData(t){const{topLeft:e,bottomRight:r}=t.boundingBox,o=r[0]-e[0],n=r[1]-e[1];return a({topLeft:e,width:o,height:n,center:[e[0]+o/2,e[1]+n/2]},t.annotations)}__getPinchPos(t,e,r,o){const n=[640,480];let i=function(t){let e=t.length;return t.reduce((t,e)=>{let[r,o,n]=t,[i,s,a]=e;return[r+i,o+s,n+a]},[0,0,0]).map(t=>t/e)}([t,e]);return[i[0]/n[0],i[1]/n[1]]}__getPinchVector(t,e,r,o){let n=c(t,e)/o;return this.__normalizeInRange(n,r)}__getRotation(t,e,r,o){let n,i=c(t,e)/o;return i<r[0]||i>r[1]?null:(n=function(t,e){let r,[o,n]=t,[i,s]=e,a=Math.atan((s-n)/(i-o));return r=a<0?a+Math.PI:a,Math.PI-r}(t,e),n)}}function f(t){return t&&"object"==typeof t&&!Array.isArray(t)}function m(t,e,r,o){if(f(r)&&f(o))for(const n in o)f(o[n])?(r[n]||Object.assign(r,{[n]:{}}),m(r[n],o[n])):Object.assign(r,{[n]:t(e,n,r[n],o[n])});return r}function y(t){return(e,r)=>{let o,n;return o=e.int_vectors?m(b,t,e.int_vectors,r.vectors):r.vectors,n=e.int_predictions?m(b,t,e.int_predictions,r.predictions):r.predictions,a({},r,{int_vectors:o,int_predictions:n})}}function b(t,e,r,o){let n,i=.1;if(e in t){let r=t[e];if(!r)return o;r.step&&(i=r.step),r.stepperFunction&&(n=r.stepperFunction)}if(Array.isArray(r)){if(Array.isArray(r[0]))return r.map((r,n)=>b(t,e,r,o[n]));if(2===r.length)return n?n(r,o,i):l(r,o,i);if(3===r.length)return n?n(r,o,i):l(r,o,i)}return"number"==typeof r?n?n(r,o,i):function(t,e,r=.1){return t+(e-t)*r}(r,o,i):o}console.clear();const w={blaze:{detector:{central_bounding:{x:[-20,20],y:[-20,15]},outer_bounding:{x:[-50,50],y:[-35,15]}},interpolator:{predictions:!0,vectors:!0,fps:1,sensitivity:.07,mapperArgs:{probability:!1},get stepperFactory(){return y}}},mesh:{detector:{central_bounding:{x:[-20,20],y:[-20,15]},outer_bounding:{x:[-50,50],y:[-35,15]},mouth_bounding:[0,25],eye_bounding:[20,32]},interpolator:{fps:0,sensitivity:.07,mapperArgs:{probability:!1},get stepperFactory(){return y}}},handpose:{detector:{central_bounding:{x:[-20,20],y:[-20,15]},outer_bounding:{x:[-50,50],y:[-35,15]},pinch1_bounding:[50,150],rotation1_bounding:[100,200],pinch2_bounding:[50,150],pinch3_bounding:[50,150],pinch4_bounding:[50,150]},interpolator:{fps:0,sensitivity:.25,mapperArgs:{probability:!1},get stepperFactory(){return y}}}};function P(t=[]){let e={};return t.forEach(t=>{let r;if("string"==typeof t)r=v(t,null),e[t]=r;else{let o=t.name;r=v(o,t.config),e[o]=r}}),new h(e)}function v(t,e){let r,o=i({},w[t],e);switch(t){case"iris":r=new _(o.detector);break;case"mesh":r=new u(o.detector);break;case"blaze":r=new p(o.detector);break;case"handpose":r=new g(o.detector)}return{detector:r,config:o}}export default P;
//# sourceMappingURL=index.modern.js.map
