import"@tensorflow/tfjs-core";import"@tensorflow/tfjs-backend-webgl";import"@tensorflow/tfjs-backend-cpu";import{load as t}from"@tensorflow-models/blazeface";import{load as e,SupportedPackages as o}from"@tensorflow-models/face-landmarks-detection";import{load as n}from"@tensorflow-models/handpose";function r(t){return t&&"object"==typeof t&&!Array.isArray(t)}function i(t,...e){if(!e.length)return t;const o=e.shift();if(r(t)&&r(o))for(const e in o)r(o[e])?(t[e]||Object.assign(t,{[e]:{}}),i(t[e],o[e])):Object.assign(t,{[e]:o[e]});return i(t,...e)}class s{constructor(t,e,o,n=!1){this.slowPromise=t,this.stepToward=e,this.fast=null,this.slow=null,this.resolved=!0,this.fps=n,this.stepArg=o}interpolate(t){return this.__updateFast(),this.__updateSlow(t),this.fast}__updateFast(){this.fast=this.fast?this.stepToward(this.fast,this.slow,this.stepArg):this.slow}async __updateSlow(t){if(this.resolved&&this.resolved){let e;if(this.resolved=!1,this.fps){const[o,n]=[this.slowPromise(t),this.__timeoutPromise()];e=(await Promise.all([o,n]))[0],this.resolved=!0,e&&(this.slow=e)}else e=await this.slowPromise(t),this.resolved=!0,e&&(this.slow=e)}}async __timeoutPromise(){return new Promise((t,e)=>{setTimeout(t,1e3/this.fps)}).then(()=>null)}}function a(){return(a=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var o=arguments[e];for(var n in o)Object.prototype.hasOwnProperty.call(o,n)&&(t[n]=o[n])}return t}).apply(this,arguments)}function c(t,e,o=.1){let n,r,[i,s]=[...t],[a,c]=[...e];return n=i+(a-i)*o,r=s+(c-s)*o,[n,r]}function l(t,e,o=.1){return t+(e-t)*o}function d(t,e){if(2===t.length)return Math.sqrt((e[0]-t[0])**2+(e[1]-t[1])**2);if(3===t.length)return Math.sqrt((e[0]-t[0])**2+(e[1]-t[1])**2+(e[2]-t[2])**2);throw new Error("please enter 2d or 3d vectors")}class h{constructor(t){this.detectors=t,this.loaded=!1,this.animationFrameId=null}async load(){let t=[];Object.values(this.detectors).forEach(e=>{t.push(e.detector.load()),e.interpolator=new s(t=>e.detector.detect(t),e.config.interpolator.stepToward,e.config.interpolator.sensitivity,e.config.interpolator.fps)}),await Promise.all(t),console.log("all loaded"),this.loaded=!0}configure(t){Object.keys(t).forEach(e=>{let o=this.detectors[e];t[e].detector&&this.__configureDetector(t[e].detector,o),t[e].interpolator&&this.__configureInterpolator(t[e].interpolator,o)})}detect(t){if(!this.loaded)return{};let e={};Object.keys(this.detectors).forEach(o=>{e[o]=this.detectors[o].interpolator.interpolate(t)});let o={};return Object.keys(this.detectors).forEach(t=>{o[t]=this.detectors[t].config}),{detections:e,configs:o}}startDetection(t,e=[]){const o=()=>{let n=this.detect(t);e.length&&e.forEach(t=>t(n)),this.animationFrameId=requestAnimationFrame(o)};o()}stopDetection(){cancelAnimationFrame(this.animationFrameId)}__configureDetector(t,e={}){Object.assign(e.config.detector,t),e.detector.configure(t)}__configureInterpolator(t,e={}){Object.assign(e.config.interpolator,t),e.interpolator=new s(t=>e.detector.detect(t),e.config.interpolator.stepToward,e.config.interpolator.sensitivity,e.config.interpolator.fps)}}class u{constructor(t){this.model=null,this.config=t}configure(t){Object.assign(this.config,t)}__getNosePointVectors(t,e,o=1){let n=this.config.outer_bounding;const r=e[0]-t[0],i=e[1]-t[1];let s=[r,i];const a=this.__getDirection(s,this.config.central_bounding),c=[r,i],l=this.__getVectorNormalized(s,n,o);return{direction_word:a,vector:c,nose_normalized_square:l,nose_normalized_circle:this.__normalizeRect2Circ(l)}}__normalizeInRange(t,e,o=[0,1]){return t>e[1]?o[1]:t<e[0]?o[0]:o[0]+(t-e[0])/(e[1]-e[0])*(o[1]-o[0])}__normalizeRect2Circ(t,e=1){let[o,n]=t,r=o>0?1:-1,i=n>0?1:-1;if(Math.sqrt(o**2+n**2)<=e)return[o,n];const s=Math.atan(n/o),a=i*Math.abs(e*Math.sin(s));return[r*Math.abs(e*Math.cos(s)),a]}__getDirection(t,e){const[o,n]=t;let r,i=e.x,s=e.y,[a,c]=i,[l,d]=s;return o<=c&&o>=a&&n<=d&&n>=l?r="center":o<c&&o>a?n>d?r="up":n<l&&(r="down"):n<d&&n>l&&(o>c?r="right":o<a&&(r="left")),r}__getVectorNormalized(t,e,o=1){const[n,r]=t;let i=e.x.map(t=>t*o),s=e.y.map(t=>t*o),[a,c]=i,[l,d]=s;return[this.__normalizeInRange(n,[a,c],[-1,1]),this.__normalizeInRange(r,[l,d],[-1,1])]}}class _ extends u{constructor(t){super(t)}async load(){this.model=await t({maxFaces:1})}async detect(t){let e=await this.model.estimateFaces(t);if(!e.length)return!1;let o=this.__getPredictionData(e[0]);const{scale:n}=o,{tip:r}=o.nose,{center:i}=o.face;let s=this.__getNosePointVectors(r,i,n);return{int_vectors:s,vectors:s,predictions:e[0]}}__getPredictionData(t){const e=t.landmarks[2],o=d(t.landmarks[0],t.landmarks[1]),n=t.topLeft,r=t.bottomRight,i=r[0]-n[0],s=r[1]-n[1];return{scale:o/85,face:{topLeft:n,bottomRight:r,width:i,height:s,center:[n[0]+i/2,n[1]+s/2]},nose:{tip:e}}}}class p extends u{constructor(t){super(t)}async load(){this.model=await e(o.mediapipeFacemesh,{maxFaces:1,shouldLoadIrisModel:!1})}async detect(t){let e=await this.model.estimateFaces({input:t,predictIrises:!1});if(!e.length)return!1;let o=this.__getPredictionData(e[0]);const{scale:n}=o,{center:r}=o.face,{rightEyeLower1:i,rightEyeUpper1:s,leftEyeLower1:c,leftEyeUpper1:l}=o.eyes,{lipsLowerInner:d,lipsUpperInner:h}=o.mouth,{tip:u}=o.nose;let _=a({},this.__getNosePointVectors(u,r,n),this.__getMouthOpenVector(d,h,n),this.__getEyesClosedVectors(i,s,c,l,n));return{int_vectors:_,vectors:_,data:o,predictions:e[0]}}__getPredictionData(t){const{topLeft:e,bottomRight:o}=t.boundingBox,n=o[0]-e[0],r=o[1]-e[1],i=[e[0]+n/2,e[1]+r/2];let{lipsLowerInner:s,lipsUpperInner:a,rightEyeLower1:c,rightEyeUpper1:l,leftEyeLower1:h,leftEyeUpper1:u}=t.annotations;s=s[5],a=a[5],c=c[4],l=l[4],h=h[4],u=u[4];const _=d(c,h);return{scale:_/85,face:{topLeft:e,bottomRight:o,width:n,height:r,center:i},eyes:{rightEyeLower1:c,rightEyeUpper1:l,leftEyeLower1:h,leftEyeUpper1:u,eyeDist:_},nose:{tip:t.scaledMesh[4]},mouth:{lipsLowerInner:s,lipsUpperInner:a}}}__getMouthOpenVector(t,e,o){let n=d(t,e)/o;return{normalized_mouth:this.__normalizeInRange(n,this.config.mouth_bounding)}}__getEyesClosedVectors(t,e,o,n,r){let i=d(t,e)/r,s=this.config.eye_bounding;const a=this.__normalizeInRange(i,s);let c=d(o,n)/r;return{normalized_eye_r:a,normalized_eye_l:this.__normalizeInRange(c,s)}}}class g extends u{constructor(t){super(t)}async load(){this.model=await e(o.mediapipeFacemesh,{maxFaces:1,shouldLoadIrisModel:!0})}async detect(t){let e=await this.model.estimateFaces({input:t,predictIrises:!0});if(!e.length)return!1;const{nose:o,center:n}=this.__getPredictionData(e[0]);return{vectors:this.__getNosePointVectors(o,n),predictions:e[0]}}__getPredictionData(t){let e=t.annotations,{leftEyeIris:o,leftEyeLower0:n,leftEyeUpper0:r}=e,i=[...n,...r],s=i.length;return{center:i.reduce((t,e,o,n)=>{let[r,i]=t,[s,a]=e;return[r+s,i+a]},[0,0]).map(t=>t/s),nose:o[0]}}}class f extends u{constructor(t){super(t)}async load(){this.model=await n()}async detect(t){const e=await this.model.estimateHands(document.querySelector("video"));if(!e.length)return!1;let o=this.__getPredictionData(e[0]),{indexFinger:n,thumb:r}=o,i=n[3],s=r[3],a=this.__getPinchPos(s,i,1),c={pinch1:this.__getPinchVector(s,i,this.config.pinch1_bounding,1),rotation1:this.__getRotation(s,i,this.config.rotation1_bounding,1),pinchPos1:a};return{int_vectors:c,vectors:c,data:o,predictions:e[0]}}__getPredictionData(t){const{topLeft:e,bottomRight:o}=t.boundingBox,n=o[0]-e[0],r=o[1]-e[1];return a({topLeft:e,width:n,height:r,center:[e[0]+n/2,e[1]+r/2]},t.annotations)}__getPinchPos(t,e,o,n){const r=[640,480];let i=function(t){let e=t.length;return t.reduce((t,e)=>{let[o,n,r]=t,[i,s,a]=e;return[o+i,n+s,r+a]},[0,0,0]).map(t=>t/e)}([t,e]);return[i[0]/r[0],i[1]/r[1]]}__getPinchVector(t,e,o,n){let r=d(t,e)/n;return this.__normalizeInRange(r,o)}__getRotation(t,e,o,n){let r,i=d(t,e)/n;return i<o[0]||i>o[1]?null:(r=function(t,e){let o,[n,r]=t,[i,s]=e,a=Math.atan((s-r)/(i-n));return o=a<0?a+Math.PI:a,Math.PI-o}(t,e),r)}}function m(t){return t&&"object"==typeof t&&!Array.isArray(t)}console.clear();let y=function t(e,o,n){if(m(o)&&m(n))for(const r in n)m(n[r])?(o[r]||Object.assign(o,{[r]:{}}),t(o[r],n[r])):Object.assign(o,{[r]:e(o[r],n[r],r)});return o}(function(t,e,o){return Array.isArray(t)?2===t.length?function(t,e,o=.1){let n,r,[i,s]=[...t],[a,c]=[...e];return n=i+(a-i)*o,r=s+(c-s)*o,[n,r]}(t,e,.1):e:"number"==typeof t?function(t,e,o=.1){return t+(e-t)*o}(t,e,.1):e},{val:[0,1],val2:[.4,.2],val3:[[.4,.2],[.4,.2],[.4,.2]],val4:3,val5:"string",val6:{val:[1,0,2]}},{val:[0,.8],val2:[.1,.1],val3:[[.4,.3],[.5,.2],[.4,.2]],val4:4,val5:"straang",val6:{val:[1,0,1]}});console.log(y);const v={blaze:{detector:{central_bounding:{x:[-20,20],y:[-20,15]},outer_bounding:{x:[-50,50],y:[-35,15]}},interpolator:{fps:0,sensitivity:.07,stepToward:w,mapper:null}},mesh:{detector:{central_bounding:{x:[-20,20],y:[-20,15]},outer_bounding:{x:[-50,50],y:[-35,15]},mouth_bounding:[0,25],eye_bounding:[20,32]},interpolator:{fps:0,sensitivity:.07,stepToward:w,mapper:null}},iris:{detector:{central_bounding:{x:[-20,20],y:[-20,15]},outer_bounding:{x:[-50,50],y:[-35,15]},mouth_bounding:[0,10],eye_bounding:[25,32]},interpolator:{fps:0,sensitivity:.07,stepToward:w,mapper:null}},handpose:{detector:{central_bounding:{x:[-20,20],y:[-20,15]},outer_bounding:{x:[-50,50],y:[-35,15]},pinch1_bounding:[50,150],rotation1_bounding:[100,200],pinch2_bounding:[50,150],pinch3_bounding:[50,150],pinch4_bounding:[50,150]},interpolator:{fps:0,sensitivity:.25,stepToward:function(t,e,o){var n,r,i;const{vectors:s}=e,{pinch1:d,rotation1:h,pinchPos1:u}=s;return a({},e,{int_vectors:{pinch1:l((null==(n=t.int_vectors)?void 0:n.pinch1)||t.vectors.pinch1,d,o),pinchPos1:c((null==(r=t.int_vectors)?void 0:r.pinchPos1)||t.vectors.pinchPos1,u,o),rotation1:l((null==(i=t.int_vectors)?void 0:i.rotation1)||t.vectors.rotation1,h,o)}})},mapper:null}}};function w(t,e,o){var n,r,i;const{vectors:s}=e,{nose_normalized_circle:d,nose_normalized_square:h,normalized_mouth:u}=s;return a({},e,{int_vectors:{nose_normalized_circle:c((null==(n=t.int_vectors)?void 0:n.nose_normalized_circle)||t.vectors.nose_normalized_circle,d,o),nose_normalized_square:c((null==(r=t.int_vectors)?void 0:r.nose_normalized_square)||t.vectors.nose_normalized_square,h,o),normalized_mouth:l((null==(i=t.int_vectors)?void 0:i.normalized_mouth)||t.vectors.normalized_mouth,u,o)}})}function b(t=[]){let e={};return t.forEach(t=>{let o;if("string"==typeof t)o=P(t,null),e[t]=o;else{let n=t.name;o=P(n,t.config),e[n]=o}}),new h(e)}function P(t,e){let o,n=i({},v[t],e);switch(t){case"iris":o=new g(n.detector);break;case"mesh":o=new p(n.detector);break;case"blaze":o=new _(n.detector);break;case"handpose":o=new f(n.detector)}return{detector:o,config:n}}export default b;
//# sourceMappingURL=index.modern.js.map
