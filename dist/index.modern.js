import"@tensorflow/tfjs-core";import"@tensorflow/tfjs-backend-webgl";import"@tensorflow/tfjs-backend-cpu";import{load as t}from"@tensorflow-models/blazeface";import{load as e,SupportedPackages as r}from"@tensorflow-models/face-landmarks-detection";import{load as o}from"@tensorflow-models/handpose";function n(t){return t&&"object"==typeof t&&!Array.isArray(t)}function i(t,...e){if(!e.length)return t;const r=e.shift();if(n(t)&&n(r))for(const e in r)n(r[e])?(t[e]||Object.assign(t,{[e]:{}}),i(t[e],r[e])):Object.assign(t,{[e]:r[e]});return i(t,...e)}class s{constructor(t,e,r=!1){this.slowPromise=t,this.stepToward=e,this.fast=null,this.slow=null,this.resolved=!0,this.fps=r}interpolate(t){return this.__updateSlow(t),this.__updateFast(),this.fast}__updateFast(){this.fast=this.fast?this.stepToward(this.fast,this.slow):this.slow}async __updateSlow(t){if(this.resolved&&this.resolved){let e;if(this.resolved=!1,this.fps){const[r,o]=[this.slowPromise(t),this.__timeoutPromise()];e=(await Promise.all([r,o]))[0],this.resolved=!0,e&&(this.slow=e)}else e=await this.slowPromise(t),this.resolved=!0,e&&(this.slow=e)}}async __timeoutPromise(){return new Promise((t,e)=>{setTimeout(t,1e3/this.fps)}).then(()=>null)}}function a(){return(a=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var r=arguments[e];for(var o in r)Object.prototype.hasOwnProperty.call(r,o)&&(t[o]=r[o])}return t}).apply(this,arguments)}function c(t,e){if(2===t.length)return Math.sqrt((e[0]-t[0])**2+(e[1]-t[1])**2);if(3===t.length)return Math.sqrt((e[0]-t[0])**2+(e[1]-t[1])**2+(e[2]-t[2])**2);throw new Error("please enter 2d or 3d vectors")}class l{constructor(t){this.detectors=t,this.loaded=!1,this.animationFrameId=null}async load(){let t=[];Object.values(this.detectors).forEach(e=>{t.push(e.detector.load());const{stepperFactory:r,mapperArgs:o,fps:n,stepDefault:i}=e.config.interpolator,a=r(o,i);e.interpolator=new s(t=>e.detector.detect(t),a,n)}),await Promise.all(t),console.log("Models loaded"),this.loaded=!0}configure(t){Object.keys(t).forEach(e=>{let r=this.detectors[e];t[e].detector&&this.__configureDetector(t[e].detector,r),t[e].interpolator&&this.__configureInterpolator(t[e].interpolator,r)})}detect(t){if(!this.loaded)return{};let e={};Object.keys(this.detectors).forEach(r=>{e[r]=this.detectors[r].interpolator.interpolate(t)});let r={};return Object.keys(this.detectors).forEach(t=>{r[t]=this.detectors[t].config}),{detections:e,configs:r}}startDetection(t,e=[]){const r=()=>{let o=this.detect(t);e.length&&e.forEach(t=>t(o)),this.animationFrameId=requestAnimationFrame(r)};r()}stopDetection(){cancelAnimationFrame(this.animationFrameId)}__configureDetector(t,e={}){Object.assign(e.config.detector,t),e.detector.configure(t)}__configureInterpolator(t,e={}){i(e.config.interpolator,t);const{stepperFactory:r,mapperArgs:o,stepDefault:n,fps:a}=e.config.interpolator,c=r(o,n);e.interpolator=new s(t=>e.detector.detect(t),c,a)}}class h{constructor(t){this.model=null,this.config=t}configure(t){Object.assign(this.config,t)}__getNosePointVectors(t,e,r=1){const o=e[0]-t[0],n=e[1]-t[1],i=[o,n],s=this.__getVectorNormalized([o,n],this.config.outer_bounding,r);return{vector:i,nose_normalized_square:s,nose_normalized_circle:this.__normalizeRect2Circ(s)}}__normalizeInRange(t,e,r=[0,1]){return t>e[1]?r[1]:t<e[0]?r[0]:r[0]+(t-e[0])/(e[1]-e[0])*(r[1]-r[0])}__normalizeRect2Circ(t,e=1){let[r,o]=t,n=r>0?1:-1,i=o>0?1:-1;if(Math.sqrt(r**2+o**2)<=e)return[r,o];const s=Math.atan(o/r),a=i*Math.abs(e*Math.sin(s));return[n*Math.abs(e*Math.cos(s)),a]}__getVectorNormalized(t,e,r=1){const[o,n]=t;let i=e.x.map(t=>t*r),s=e.y.map(t=>t*r),[a,c]=i,[l,h]=s;return[this.__normalizeInRange(o,[a,c],[-1,1]),this.__normalizeInRange(n,[l,h],[-1,1])]}__getDirection(t,e){const[r,o]=t;let n,i=e.x,s=e.y,[a,c]=i,[l,h]=s;return r<=c&&r>=a&&o<=h&&o>=l?n="center":r<c&&r>a?o>h?n="up":o<l&&(n="down"):o<h&&o>l&&(r>c?n="right":r<a&&(n="left")),n}}class p extends h{constructor(t){super(t)}async load(){this.model=await t({maxFaces:1})}async detect(t){let e=await this.model.estimateFaces(t);if(!e.length)return!1;let r=this.__getPredictionData(e[0]);const{scale:o}=r,{tip:n}=r.nose,{center:i}=r.face;return{vectors:this.__getNosePointVectors(n,i,o),predictions:e[0]}}__getPredictionData(t){const e=t.landmarks[2],r=c(t.landmarks[0],t.landmarks[1]),o=t.topLeft,n=t.bottomRight,i=n[0]-o[0],s=n[1]-o[1];return{scale:r/85,face:{topLeft:o,bottomRight:n,width:i,height:s,center:[o[0]+i/2,o[1]+s/2]},nose:{tip:e}}}}class d extends h{constructor(t){super(t)}async load(){this.model=await e(r.mediapipeFacemesh,{maxFaces:1,shouldLoadIrisModel:!1})}async detect(t){let e=await this.model.estimateFaces({input:t,predictIrises:!1});if(!e.length)return!1;let r=this.__getPredictionData(e[0]);const{scale:o}=r,{center:n}=r.face,{rightEyeLower1:i,rightEyeUpper1:s,leftEyeLower1:c,leftEyeUpper1:l}=r.eyes,{lipsLowerInner:h,lipsUpperInner:p}=r.mouth,{tip:d}=r.nose;let u=a({},this.__getNosePointVectors(d,n,o),this.__getMouthOpenVector(h,p,o),this.__getEyesClosedVectors(i,s,c,l,o));return{int_vectors:u,vectors:u,data:r,predictions:e[0]}}__getPredictionData(t){const{topLeft:e,bottomRight:r}=t.boundingBox,o=r[0]-e[0],n=r[1]-e[1],i=[e[0]+o/2,e[1]+n/2];let{lipsLowerInner:s,lipsUpperInner:a,rightEyeLower1:l,rightEyeUpper1:h,leftEyeLower1:p,leftEyeUpper1:d}=t.annotations;s=s[5],a=a[5],l=l[4],h=h[4],p=p[4],d=d[4];const u=c(l,p);return{scale:u/85,face:{topLeft:e,bottomRight:r,width:o,height:n,center:i},eyes:{rightEyeLower1:l,rightEyeUpper1:h,leftEyeLower1:p,leftEyeUpper1:d,eyeDist:u},nose:{tip:t.scaledMesh[4]},mouth:{lipsLowerInner:s,lipsUpperInner:a}}}__getMouthOpenVector(t,e,r){let o=c(t,e)/r;return{normalized_mouth:this.__normalizeInRange(o,this.config.mouth_bounding)}}__getEyesClosedVectors(t,e,r,o,n){let i=c(t,e)/n,s=this.config.eye_bounding;const a=this.__normalizeInRange(i,s);let l=c(r,o)/n;return{normalized_eye_r:a,normalized_eye_l:this.__normalizeInRange(l,s)}}}class u extends h{constructor(t){super(t)}async load(){this.model=await e(r.mediapipeFacemesh,{maxFaces:1,shouldLoadIrisModel:!0})}async detect(t){let e=await this.model.estimateFaces({input:t,predictIrises:!0});if(!e.length)return!1;const{nose:r,center:o}=this.__getPredictionData(e[0]);return{vectors:this.__getNosePointVectors(r,o),predictions:e[0]}}__getPredictionData(t){let e=t.annotations,{leftEyeIris:r,leftEyeLower0:o,leftEyeUpper0:n}=e,i=[...o,...n],s=i.length;return{center:i.reduce((t,e,r,o)=>{let[n,i]=t,[s,a]=e;return[n+s,i+a]},[0,0]).map(t=>t/s),nose:r[0]}}}class f extends h{constructor(t){super(t)}async load(){this.model=await o()}async detect(t){const e=await this.model.estimateHands(t);if(!e.length)return!1;let r=this.__getPredictionData(e[0]),{indexFinger:o,thumb:n}=r,i=o[3],s=n[3],a=this.__getPinchPos(s,i,1);return{vectors:{pinch1:this.__getPinchVector(s,i,this.config.pinch1_bounding,1),rotation1:this.__getRotation(s,i,this.config.rotation1_bounding,1),pinchPos1:a},data:r,predictions:e[0]}}__getPredictionData(t){const{topLeft:e,bottomRight:r}=t.boundingBox,o=r[0]-e[0],n=r[1]-e[1];return a({topLeft:e,width:o,height:n,center:[e[0]+o/2,e[1]+n/2]},t.annotations)}__getPinchPos(t,e,r,o){const n=[640,480];let i=function(t){let e=t.length;return t.reduce((t,e)=>{let[r,o,n]=t,[i,s,a]=e;return[r+i,o+s,n+a]},[0,0,0]).map(t=>t/e)}([t,e]);return[i[0]/n[0],i[1]/n[1]]}__getPinchVector(t,e,r,o){let n=c(t,e)/o;return this.__normalizeInRange(n,r)}__getRotation(t,e,r,o){let n,i=c(t,e)/o;return i<r[0]||i>r[1]?null:(n=function(t,e){let r,[o,n]=t,[i,s]=e,a=Math.atan((s-n)/(i-o));return r=a<0?a+Math.PI:a,Math.PI-r}(t,e),n)}}function g(t){return t&&"object"==typeof t&&!Array.isArray(t)}function _(t,e,r,o){if(g(r)&&g(o))for(const n in o)g(o[n])?(r[n]||Object.assign(r,{[n]:{}}),_(t,e,r[n],o[n])):Object.assign(r,{[n]:t(e,n,r[n],o[n])});return r}function m(t,e=.1){return(e,o)=>{let n,i;return n=e.int_vectors?_(r,t,e.int_vectors,o.vectors):o.vectors,i=e.int_predictions?_(r,t,e.int_predictions,o.predictions):o.predictions,a({},o,{int_vectors:n,int_predictions:i})};function r(t,o,n,i){let s,a=e;if(o in t){let e=t[o];if(!e)return i;e.step&&(a=e.step),e.stepperFunction&&(s=e.stepperFunction)}if(Array.isArray(n)){if(Array.isArray(n[0]))return n.map((e,n)=>r(t,o,e,i[n]));if(2===n.length)return s?s(n,i,a):function(t,e,r=.1){let o,n,[i,s]=[...t],[a,c]=[...e];return o=i+(a-i)*r,n=s+(c-s)*r,[o,n]}(n,i,a);if(3===n.length)return s?s(n,i,a):function(t,e,r=.1){let o,n,i,[s,a,c]=[...t],[l,h,p]=[...e];return o=s+(l-s)*r,n=a+(h-a)*r,i=c+(p-c)*r,[o,n,i]}(n,i,a)}return"number"==typeof n?s?s(n,i,a):function(t,e,r=.1){return t+(e-t)*r}(n,i,a):i}}console.clear();const y={blaze:{detector:{outer_bounding:{x:[-50,50],y:[-35,15]}},interpolator:{predictions:!0,vectors:!0,fps:0,stepDefault:.1,mapperArgs:{probability:!1},get stepperFactory(){return m}}},mesh:{detector:{outer_bounding:{x:[-50,50],y:[-35,15]},mouth_bounding:[0,25],eye_bounding:[20,32]},interpolator:{fps:0,stepDefault:.07,mapperArgs:{probability:!1},get stepperFactory(){return m}}},handpose:{detector:{outer_bounding:{x:[-50,50],y:[-35,15]},pinch1_bounding:[50,150],rotation1_bounding:[100,200],pinch2_bounding:[50,150],pinch3_bounding:[50,150],pinch4_bounding:[50,150]},interpolator:{fps:0,stepDefault:.25,mapperArgs:{probability:!1},get stepperFactory(){return m}}}};function w(t=[]){let e={};return t.forEach(t=>{let r;if("string"==typeof t)r=b(t,null),e[t]=r;else{let o=t.name;r=b(o,t.config),e[o]=r}}),new l(e)}function b(t,e){let r,o=i({},y[t],e);switch(console.log(o),t){case"iris":r=new u(o.detector);break;case"mesh":r=new d(o.detector);break;case"blaze":r=new p(o.detector);break;case"handpose":r=new f(o.detector)}return{detector:r,config:o}}export default w;
//# sourceMappingURL=index.modern.js.map
